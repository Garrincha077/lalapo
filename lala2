import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
import sqlite3
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure
import threading
import time
import logging
from datetime import datetime, timedelta
from ttkthemes import ThemedTk
import csv
from pathlib import Path
import json
import requests
from decimal import Decimal

# Konfiguracija logginga
logging.basicConfig(
    filename='trading_app.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

logger = logging.getLogger(__name__)

class DatabaseManager:
    def __init__(self, db_path='trading_app.db'):
        self.db_path = db_path
        self.conn = None
        self.cursor = None
        self.connect()
        self.setup_database()

    def connect(self):
        try:
            self.conn = sqlite3.connect(self.db_path, check_same_thread=False)
            self.cursor = self.conn.cursor()
        except Exception as e:
            logger.error(f"Database connection error: {e}")
            raise

    def setup_database(self):
        try:
            # Main portfolio table
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS portfolio (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    entry_price REAL NOT NULL,
                    exit_price REAL,
                    stop_loss REAL,
                    take_profit REAL,
                    quantity INTEGER NOT NULL,
                    entry_date TEXT NOT NULL,
                    exit_date TEXT,
                    pnl REAL,
                    trade_type TEXT NOT NULL,
                    status TEXT NOT NULL,
                    notes TEXT
                )
            ''')

            # Trading statistics table
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS trading_statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date TEXT NOT NULL,
                    total_trades INTEGER,
                    winning_trades INTEGER,
                    losing_trades INTEGER,
                    win_rate REAL,
                    profit_factor REAL,
                    average_win REAL,
                    average_loss REAL,
                    largest_win REAL,
                    largest_loss REAL,
                    total_pnl REAL
                )
            ''')

            # Trade journal table
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS trade_journal (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    trade_id INTEGER,
                    entry_date TEXT NOT NULL,
                    notes TEXT,
                    strategy TEXT,
                    market_conditions TEXT,
                    FOREIGN KEY (trade_id) REFERENCES portfolio (id)
                )
            ''')

            self.conn.commit()
        except Exception as e:
            logger.error(f"Database setup error: {e}")
            raise

    def execute_query(self, query, parameters=None):
        try:
            if parameters:
                self.cursor.execute(query, parameters)
            else:
                self.cursor.execute(query)
            self.conn.commit()
            return self.cursor.fetchall()
        except Exception as e:
            logger.error(f"Query execution error: {query} - {e}")
            self.conn.rollback()
            raise

    def close(self):
        if self.conn:
            self.conn.close()

class MarketDataManager:
    def __init__(self):
        self.cache = {}
        self.cache_timeout = {
            '1h': 300,  # 5 minutes cache for hourly data
            '1d': 3600,  # 1 hour cache for daily data
            '1w': 14400  # 4 hours cache for weekly data
        }
        
    def get_historical_data(self, symbol, period='1y', interval='1d'):
        """
        Get historical data for a symbol with specified period and interval
        
        Parameters:
        - symbol: str, the ticker symbol
        - period: str, the lookback period (e.g., '1d', '5d', '1mo', '1y')
        - interval: str, the data interval ('1h', '1d', '1w')
        """
        try:
            cache_key = f"{symbol}_{period}_{interval}"
            current_time = time.time()
            
            # Check cache
            if cache_key in self.cache:
                cached_data = self.cache[cache_key]
                if current_time - cached_data['timestamp'] < self.cache_timeout.get(interval, 3600):
                    return cached_data['data']
            
            ticker = yf.Ticker(symbol)
            
            # Adjust period based on interval to ensure enough data
            if interval == '1h':
                # For hourly data, limit to max 60 days of history
                period = min(period, '60d')
            elif interval == '1w':
                # For weekly data, ensure at least 1 year of history
                period = max(period, '1y')
            
            data = ticker.history(period=period, interval=interval)
            
            # Cache the data
            self.cache[cache_key] = {
                'data': data,
                'timestamp': current_time
            }
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching historical data for {symbol}: {e}")
            return pd.DataFrame()

    def calculate_atr(self, symbol, timeframe='1d', period=14):
        """
        Calculate ATR for different timeframes
        
        Parameters:
        - symbol: str, the ticker symbol
        - timeframe: str, the timeframe for calculation ('1h', '1d', '1w')
        - period: int, the ATR period (default: 14)
        """
        try:
            # Define lookback periods based on timeframe
            lookback_periods = {
                '1h': '7d',    # 7 days for hourly data
                '1d': '30d',   # 30 days for daily data
                '1w': '52w'    # 52 weeks for weekly data
            }
            
            period_to_fetch = lookback_periods.get(timeframe, '30d')
            data = self.get_historical_data(symbol, period=period_to_fetch, interval=timeframe)
            
            if data.empty:
                return None
            
            # Calculate True Range
            data['H-L'] = data['High'] - data['Low']
            data['H-PC'] = abs(data['High'] - data['Close'].shift(1))
            data['L-PC'] = abs(data['Low'] - data['Close'].shift(1))
            
            data['TR'] = data[['H-L', 'H-PC', 'L-PC']].max(axis=1)
            
            # Calculate ATR using different methods based on timeframe
            if timeframe == '1h':
                # For hourly data, use EMA for more responsiveness
                data['ATR'] = data['TR'].ewm(span=period, adjust=False).mean()
            else:
                # For daily and weekly, use simple moving average
                data['ATR'] = data['TR'].rolling(window=period).mean()
            
            # Additional statistics
            atr_stats = {
                'current': data['ATR'].iloc[-1],
                'mean': data['ATR'].mean(),
                'max': data['ATR'].max(),
                'min': data['ATR'].min(),
                'stddev': data['ATR'].std()
            }
            
            return atr_stats
            
        except Exception as e:
            logger.error(f"Error calculating ATR for {symbol} on {timeframe} timeframe: {e}")
            return None

class RiskManagement:
    def __init__(self, account_balance, max_risk_per_trade=0.02):
        self.account_balance = account_balance
        self.max_risk_per_trade = max_risk_per_trade

    def calculate_position_size(self, entry_price, stop_loss):
        try:
            risk_amount = self.account_balance * self.max_risk_per_trade
            risk_per_share = abs(entry_price - stop_loss)
            if risk_per_share == 0:
                return 0
            position_size = int(risk_amount / risk_per_share)
            return position_size
        except Exception as e:
            logger.error(f"Error calculating position size: {e}")
            return 0

    def calculate_risk_metrics(self, position_size, entry_price, stop_loss, take_profit):
        try:
            risk_per_share = abs(entry_price - stop_loss)
            reward_per_share = abs(take_profit - entry_price)
            total_risk = risk_per_share * position_size
            total_reward = reward_per_share * position_size
            risk_reward_ratio = reward_per_share / risk_per_share if risk_per_share > 0 else 0
            
            return {
                'risk_per_share': risk_per_share,
                'reward_per_share': reward_per_share,
                'total_risk': total_risk,
                'total_reward': total_reward,
                'risk_reward_ratio': risk_reward_ratio,
                'risk_percentage': (total_risk / self.account_balance) * 100
            }
        except Exception as e:
            logger.error(f"Error calculating risk metrics: {e}")
            return None

    def validate_trade(self, entry_price, stop_loss, take_profit):
        """
        Validacija trgovine prema rizik/reward kriterijima
        """
        try:
            risk = abs(entry_price - stop_loss)
            reward = abs(take_profit - entry_price)
            
            # Minimalni rizik/reward ratio 1:2
            if reward / risk < 2:
                return False, "Risk/Reward ratio should be at least 1:2"
            
            # Maksimalni rizik po trgovini
            max_risk = self.account_balance * self.max_risk_per_trade
            if risk > max_risk:
                return False, f"Risk exceeds maximum allowed risk of ${max_risk:.2f}"
            
            return True, "Trade validation successful"
        except Exception as e:
            logger.error(f"Error validating trade: {e}")
            return False, f"Error validating trade: {str(e)}"

class PortfolioTracker(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.market_data = MarketDataManager()
        self.setup_ui()
        self.start_auto_refresh()

    def setup_ui(self):
        # Glavni okvir za treeview
        columns = ("ID", "Symbol", "Entry Price", "Current Price", "Stop Loss", 
                  "Take Profit", "Quantity", "PnL", "PnL %", "Status")
        
        self.tree = ttk.Treeview(self, columns=columns, show="headings", height=10)
        
        # Konfiguracija stupaca
        self.tree.column("ID", width=50, anchor="center")
        for col in columns[1:]:
            self.tree.heading(col, text=col)
            width = 100 if col not in ["Symbol", "Status"] else 80
            self.tree.column(col, width=width, anchor="center")
        
        # Sakrivanje ID stupca
        self.tree.column("#1", stretch=False, width=0)
        
        # Scrollbars
        y_scroll = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
        x_scroll = ttk.Scrollbar(self, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=y_scroll.set, xscrollcommand=x_scroll.set)
        
        # Pakiranje elemenata
        y_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        x_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Frame za gumbe
        btn_frame = ttk.Frame(self)
        btn_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Gumbi
        ttk.Button(btn_frame, text="Close Position", 
                  command=self.close_position).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Modify Position", 
                  command=self.modify_position).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Add Note", 
                  command=self.add_note).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Export Data", 
                  command=self.export_data).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Refresh", 
                  command=self.refresh).pack(side=tk.LEFT, padx=5)

    def load_positions(self):
        db = DatabaseManager()
        try:
            positions = db.execute_query('''
                SELECT id, symbol, entry_price, stop_loss, take_profit, quantity, 
                       pnl, status FROM portfolio WHERE status = 'Open'
            ''')
            
            for position in positions:
                position_id, symbol, entry_price = position[0:3]
                current_price = self.market_data.get_real_time_price(symbol)
                
                if current_price:
                    quantity = position[5]
                    pnl = (current_price - entry_price) * quantity
                    pnl_percentage = (pnl / (entry_price * quantity)) * 100
                    
                    values = list(position)
                    values.insert(3, current_price)  # Dodaj trenutnu cijenu
                    values[6] = f"${pnl:.2f}"       # Formatiraj PnL
                    values.insert(7, f"{pnl_percentage:.2f}%")  # Dodaj PnL postotak
                    
                    # Dodaj boju ovisno o PnL
                    tag = 'profit' if pnl > 0 else 'loss'
                    self.tree.insert("", tk.END, values=values, tags=(tag,))
                    
            # Konfiguriraj boje za PnL
            self.tree.tag_configure('profit', foreground='green')
            self.tree.tag_configure('loss', foreground='red')
            
        except Exception as e:
            logger.error(f"Error loading positions: {e}")
            messagebox.showerror("Error", f"Failed to load positions: {str(e)}")
        finally:
            db.close()

    def close_position(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Selection Error", "Please select a position to close.")
            return

        position = self.tree.item(selected[0])['values']
        position_id = position[0]
        symbol = position[1]
        current_price = self.market_data.get_real_time_price(symbol)
        
        if current_price:
            if messagebox.askyesno("Confirm Close",
                                 f"Close position {symbol} at ${current_price:.2f}?"):
                self.execute_close_position(position_id, current_price)

    def execute_close_position(self, position_id, exit_price):
        db = DatabaseManager()
        try:
            # Dohvati podatke o poziciji
            position = db.execute_query('''
                SELECT entry_price, quantity FROM portfolio WHERE id = ?
            ''', (position_id,))[0]
            
            entry_price, quantity = position
            pnl = (exit_price - entry_price) * quantity
            
            # Ažuriraj poziciju
            db.execute_query('''
                UPDATE portfolio
                SET exit_price = ?, exit_date = ?, pnl = ?, status = 'Closed'
                WHERE id = ?
            ''', (exit_price, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), 
                 pnl, position_id))
            
            self.refresh()
            messagebox.showinfo("Success", f"Position closed with PnL: ${pnl:.2f}")
            
            # Ažuriraj statistiku i zatvorene trgovine
            if hasattr(self.master, 'statistics'):
                self.master.statistics.calculate_statistics()
            if hasattr(self.master, 'closed_trades'):
                self.master.closed_trades.load_closed_trades()
            
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            messagebox.showerror("Error", "Failed to close position.")
        finally:
            db.close()

    def modify_position(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Selection Error", "Please select a position to modify.")
            return

        position = self.tree.item(selected[0])['values']
        position_id = position[0]
        
        modify_window = tk.Toplevel(self)
        modify_window.title("Modify Position")
        modify_window.geometry("300x200")
        
        ttk.Label(modify_window, text="Stop Loss:").pack(pady=5)
        stop_loss_entry = ttk.Entry(modify_window)
        stop_loss_entry.insert(0, str(position[4]))
        stop_loss_entry.pack(pady=5)
        
        ttk.Label(modify_window, text="Take Profit:").pack(pady=5)
        take_profit_entry = ttk.Entry(modify_window)
        take_profit_entry.insert(0, str(position[5]))
        take_profit_entry.pack(pady=5)
        
        def save_modifications():
            try:
                db = DatabaseManager()
                db.execute_query('''
                    UPDATE portfolio
                    SET stop_loss = ?, take_profit = ?
                    WHERE id = ?
                ''', (float(stop_loss_entry.get()), 
                     float(take_profit_entry.get()), position_id))
                modify_window.destroy()
                self.refresh()
                messagebox.showinfo("Success", "Position updated successfully!")
            except Exception as e:
                logger.error(f"Error modifying position: {e}")
                messagebox.showerror("Error", "Failed to modify position.")
            finally:
                db.close()
        
        ttk.Button(modify_window, text="Save", 
                  command=save_modifications).pack(pady=20)

    def add_note(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Selection Error", 
                                 "Please select a position to add a note.")
            return

        position_id = self.tree.item(selected[0])['values'][0]
        note = simpledialog.askstring("Add Note", "Enter note:")
        
        if note:
            db = DatabaseManager()
            try:
                db.execute_query('''
                    INSERT INTO trade_journal (trade_id, entry_date, notes)
                    VALUES (?, ?, ?)
                ''', (position_id, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), note))
                messagebox.showinfo("Success", "Note added successfully!")
            except Exception as e:
                logger.error(f"Error adding note: {e}")
                messagebox.showerror("Error", "Failed to add note.")
            finally:
                db.close()

    def export_data(self):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), 
                      ("Excel files", "*.xlsx"), 
                      ("All files", "*.*")]
        )
        if not file_path:
            return
            
        db = DatabaseManager()
        try:
            data = db.execute_query('''
                SELECT * FROM portfolio
                ORDER BY entry_date DESC
            ''')
            
            df = pd.DataFrame(data, columns=[
                'ID', 'Symbol', 'Entry Price', 'Exit Price', 'Stop Loss',
                'Take Profit', 'Quantity', 'Entry Date', 'Exit Date', 'PnL',
                'Trade Type', 'Status', 'Notes'
            ])
            
            if file_path.endswith('.csv'):
                df.to_csv(file_path, index=False)
            else:
                df.to_excel(file_path, index=False)
                
            messagebox.showinfo("Success", "Data exported successfully!")
        except Exception as e:
            logger.error(f"Error exporting data: {e}")
            messagebox.showerror("Error", "Failed to export data.")
        finally:
            db.close()

    def refresh(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
        self.load_positions()

    def start_auto_refresh(self):
        self.refresh()
        self.after(30000, self.start_auto_refresh)  # Osvježi svakih 30 sekundi

class PositionCalculator(ttk.Frame):
    def __init__(self, parent, account_balance=10000.0, risk_percentage=2.0, portfolio_tracker=None):
        super().__init__(parent)
        self.account_balance = account_balance
        self.risk_percentage = risk_percentage
        self.portfolio_tracker = portfolio_tracker
        self.market_data = MarketDataManager()
        self.setup_ui()
        
    def setup_price_entries(self, parent_frame):
        # ... (previous code remains the same until ATR settings) ...

        # ATR Settings Frame
        self.atr_frame = ttk.LabelFrame(parent_frame, text="ATR Settings", padding=5)
        self.atr_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=5)

        # ATR Timeframe selection
        ttk.Label(self.atr_frame, text="ATR Timeframe:").grid(row=0, column=0)
        self.atr_timeframe = tk.StringVar(value='1d')
        timeframe_combo = ttk.Combobox(self.atr_frame, 
                                     textvariable=self.atr_timeframe,
                                     values=['1h', '1d', '1w'],
                                     state='readonly',
                                     width=10)
        timeframe_combo.grid(row=0, column=1)
        timeframe_combo.bind('<<ComboboxSelected>>', self.update_atr_calculation)

        # ATR Period
        ttk.Label(self.atr_frame, text="ATR Period:").grid(row=1, column=0)
        self.atr_period_var = tk.StringVar(value='14')
        ttk.Entry(self.atr_frame, 
                 textvariable=self.atr_period_var,
                 width=10).grid(row=1, column=1)

        # ATR Information Display
        self.atr_info_frame = ttk.Frame(self.atr_frame)
        self.atr_info_frame.grid(row=2, column=0, columnspan=2, pady=5)

        self.current_atr_label = ttk.Label(self.atr_info_frame, text="Current ATR: N/A")
        self.current_atr_label.pack()

        self.avg_atr_label = ttk.Label(self.atr_info_frame, text="Average ATR: N/A")
        self.avg_atr_label.pack()

        self.atr_range_label = ttk.Label(self.atr_info_frame, text="ATR Range: N/A")
        self.atr_range_label.pack()

    def update_atr_calculation(self, event=None):
        """Update ATR calculations when timeframe changes"""
        symbol = self.symbol_var.get().upper()
        if not symbol:
            return

        try:
            period = int(self.atr_period_var.get())
            timeframe = self.atr_timeframe.get()
            
            atr_stats = self.market_data.calculate_atr(symbol, timeframe, period)
            
            if atr_stats:
                self.current_atr_label.config(
                    text=f"Current ATR: ${atr_stats['current']:.2f}")
                self.avg_atr_label.config(
                    text=f"Average ATR: ${atr_stats['mean']:.2f}")
                self.atr_range_label.config(
                    text=f"ATR Range: ${atr_stats['min']:.2f} - ${atr_stats['max']:.2f}")
                
                # If using ATR-based stop loss, update the calculation
                if self.stop_loss_type.get() == "ATR":
                    self.calculate_atr_stop_loss()
            
        except ValueError:
            messagebox.showerror("Error", "Invalid ATR period")
        except Exception as e:
            logger.error(f"Error updating ATR calculation: {e}")
            messagebox.showerror("Error", "Failed to update ATR calculation")

    def calculate_atr_stop_loss(self):
        """Calculate stop loss based on ATR"""
        symbol = self.symbol_var.get().upper()
        if not symbol:
            return
            
        try:
            current_price = float(self.entry_price_var.get())
            period = int(self.atr_period_var.get())
            timeframe = self.atr_timeframe.get()
            multiplier = float(self.atr_multiplier_var.get())
            
            atr_stats = self.market_data.calculate_atr(symbol, timeframe, period)
            
            if atr_stats:
                atr = atr_stats['current']
                self.atr_value_label.configure(
                    text=f"Current ATR ({timeframe}): ${atr:.2f}")
                
                if self.stop_loss_type.get() == "ATR":
                    if self.trade_type.get() == "Long":
                        stop_loss = current_price - (atr * multiplier)
                    else:
                        stop_loss = current_price + (atr * multiplier)
                        
                    self.stop_loss_var.set(f"{stop_loss:.2f}")
                    
                    # Calculate and display potential loss
                    risk_amount = abs(current_price - stop_loss)
                    self.risk_amount_label.config(
                        text=f"Risk per share: ${risk_amount:.2f}")
            
        except ValueError:
            messagebox.showerror("Error", "Invalid input values")
        except Exception as e:
            logger.error(f"Error calculating ATR stop loss: {e}")
            messagebox.showerror("Error", "Failed to calculate ATR stop loss")

class ClosedTradesTab(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.setup_ui()
        self.load_closed_trades()

    def setup_ui(self):
        # Kreiranje Treeview-a za zatvorene trgovine
        columns = ("ID", "Symbol", "Entry Price", "Exit Price", "Stop Loss",
                  "Take Profit", "Quantity", "PnL", "Trade Type", "Entry Date", "Exit Date")
        
        self.tree = ttk.Treeview(self, columns=columns, show="headings", height=10)
        
        # Konfiguracija stupaca
        for col in columns:
            self.tree.heading(col, text=col)
            width = 100 if col not in ["Symbol", "Trade Type"] else 80
            self.tree.column(col, width=width, anchor="center")
        
        # Scrollbars
        y_scroll = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
        x_scroll = ttk.Scrollbar(self, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=y_scroll.set, xscrollcommand=x_scroll.set)
        
        # Pakiranje elemenata
        y_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        x_scroll.pack(side=tk.BOTTOM, fill=tk.X)
        self.tree.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Gumb za osvježavanje
        ttk.Button(self, text="Refresh", 
                  command=self.load_closed_trades).pack(pady=5)

        # Gumb za izvoz podataka
        ttk.Button(self, text="Export to CSV", 
                  command=self.export_closed_trades).pack(pady=5)

    def load_closed_trades(self):
        self.tree.delete(*self.tree.get_children())
        db = DatabaseManager()
        try:
            trades = db.execute_query('''
                SELECT id, symbol, entry_price, exit_price, stop_loss,
                       take_profit, quantity, pnl, trade_type, entry_date, exit_date
                FROM portfolio 
                WHERE status = 'Closed'
                ORDER BY exit_date DESC
            ''')
            
            for trade in trades:
                # Formatiraj PnL s bojom
                pnl = trade[7]
                pnl_formatted = f"${pnl:.2f}"
                
                values = list(trade)
                values[7] = pnl_formatted
                
                # Umetni s tagovima za boju
                tag = 'profit' if pnl > 0 else 'loss'
                self.tree.insert("", tk.END, values=values, tags=(tag,))
            
            # Konfiguriraj boje tagova
            self.tree.tag_configure('profit', foreground='green')
            self.tree.tag_configure('loss', foreground='red')
            
        except Exception as e:
            logger.error(f"Error loading closed trades: {e}")
            messagebox.showerror("Error", "Failed to load closed trades.")
        finally:
            db.close()

    def export_closed_trades(self):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), 
                      ("Excel files", "*.xlsx")]
        )
        if not file_path:
            return
            
        db = DatabaseManager()
        try:
            trades = db.execute_query('''
                SELECT * FROM portfolio 
                WHERE status = 'Closed'
                ORDER BY exit_date DESC
            ''')
            
            df = pd.DataFrame(trades, columns=[
                'ID', 'Symbol', 'Entry Price', 'Exit Price', 'Stop Loss',
                'Take Profit', 'Quantity', 'Entry Date', 'Exit Date', 'PnL',
                'Trade Type', 'Status', 'Notes'
            ])
            
            if file_path.endswith('.csv'):
                df.to_csv(file_path, index=False)
            else:
                df.to_excel(file_path, index=False)
                
            messagebox.showinfo("Success", "Closed trades exported successfully!")
        except Exception as e:
            logger.error(f"Error exporting closed trades: {e}")
            messagebox.showerror("Error", "Failed to export closed trades.")
        finally:
            db.close()

class StatisticsTab(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.setup_ui()
        self.calculate_statistics()

    def setup_ui(self):
        # Glavni okvir za statistiku
        stats_frame = ttk.LabelFrame(self, text="Trading Performance", padding=10)
        stats_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Ukupna statistika
        overall_frame = ttk.LabelFrame(stats_frame, text="Overall Statistics", padding=5)
        overall_frame.pack(fill=tk.X, padx=5, pady=5)

        self.total_trades_label = ttk.Label(overall_frame, text="Total Trades: ")
        self.total_trades_label.pack(pady=2)

        self.winning_trades_label = ttk.Label(overall_frame, text="Winning Trades: ")
        self.winning_trades_label.pack(pady=2)

        self.losing_trades_label = ttk.Label(overall_frame, text="Losing Trades: ")
        self.losing_trades_label.pack(pady=2)

        self.win_rate_label = ttk.Label(overall_frame, text="Win Rate: ")
        self.win_rate_label.pack(pady=2)

        # Statistika profita
        profit_frame = ttk.LabelFrame(stats_frame, text="Profit Statistics", padding=5)
        profit_frame.pack(fill=tk.X, padx=5, pady=5)

        self.total_pnl_label = ttk.Label(profit_frame, text="Total P&L: ")
        self.total_pnl_label.pack(pady=2)

        self.profit_factor_label = ttk.Label(profit_frame, text="Profit Factor: ")
        self.profit_factor_label.pack(pady=2)

        self.avg_win_label = ttk.Label(profit_frame, text="Average Win: ")
        self.avg_win_label.pack(pady=2)

        self.avg_loss_label = ttk.Label(profit_frame, text="Average Loss: ")
        self.avg_loss_label.pack(pady=2)

        self.largest_win_label = ttk.Label(profit_frame, text="Largest Win: ")
        self.largest_win_label.pack(pady=2)

        self.largest_loss_label = ttk.Label(profit_frame, text="Largest Loss: ")
        self.largest_loss_label.pack(pady=2)

        # Rizične statistike
        risk_frame = ttk.LabelFrame(stats_frame, text="Risk Metrics", padding=5)
        risk_frame.pack(fill=tk.X, padx=5, pady=5)

        self.avg_rr_label = ttk.Label(risk_frame, text="Average R:R Ratio: ")
        self.avg_rr_label.pack(pady=2)

        self.avg_hold_time_label = ttk.Label(risk_frame, text="Average Hold Time: ")
        self.avg_hold_time_label.pack(pady=2)

        # Gumb za osvježavanje
        ttk.Button(self, text="Refresh Statistics", 
                  command=self.calculate_statistics).pack(pady=10)

    def calculate_statistics(self):
        db = DatabaseManager()
        try:
            # Fetch closed trades
            trades = db.execute_query('''
                SELECT pnl, entry_date, exit_date, entry_price, exit_price,
                       stop_loss, take_profit
                FROM portfolio 
                WHERE status = 'Closed'
            ''')
            
            if not trades:
                messagebox.showinfo("No Data", "No closed trades found.")
                return
                
            # Convert to pandas DataFrame for easier calculations
            df = pd.DataFrame(trades, columns=['pnl', 'entry_date', 'exit_date', 
                                             'entry_price', 'exit_price', 
                                             'stop_loss', 'take_profit'])
            
            # Basic statistics
            total_trades = len(df)
            winning_trades = len(df[df['pnl'] > 0])
            losing_trades = len(df[df['pnl'] < 0])
            win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
            
            # Profit statistics
            total_pnl = df['pnl'].sum()
            total_profit = df[df['pnl'] > 0]['pnl'].sum()
            total_loss = abs(df[df['pnl'] < 0]['pnl'].sum())
            profit_factor = total_profit / total_loss if total_loss != 0 else float('inf')
            
            avg_win = df[df['pnl'] > 0]['pnl'].mean() if winning_trades > 0 else 0
            avg_loss = df[df['pnl'] < 0]['pnl'].mean() if losing_trades > 0 else 0
            largest_win = df['pnl'].max()
            largest_loss = df['pnl'].min()
            
            # Calculate average hold time
            df['entry_date'] = pd.to_datetime(df['entry_date'])
            df['exit_date'] = pd.to_datetime(df['exit_date'])
            df['hold_time'] = (df['exit_date'] - df['entry_date'])
            avg_hold_time = df['hold_time'].mean()
            
            # Calculate average R:R ratio
            df['risk'] = abs(df.apply(lambda x: x['entry_price'] - x['stop_loss'], axis=1))
            df['reward'] = abs(df.apply(lambda x: x['take_profit'] - x['entry_price'], axis=1))
            avg_rr = (df['reward'] / df['risk']).mean()
            
            # Update labels
            self.total_trades_label.config(text=f"Total Trades: {total_trades}")
            self.winning_trades_label.config(text=f"Winning Trades: {winning_trades}")
            self.losing_trades_label.config(text=f"Losing Trades: {losing_trades}")
            self.win_rate_label.config(text=f"Win Rate: {win_rate:.2f}%")
            
            self.total_pnl_label.config(text=f"Total P&L: ${total_pnl:.2f}")
            self.profit_factor_label.config(text=f"Profit Factor: {profit_factor:.2f}")
            self.avg_win_label.config(text=f"Average Win: ${avg_win:.2f}")
            self.avg_loss_label.config(text=f"Average Loss: ${avg_loss:.2f}")
            self.largest_win_label.config(text=f"Largest Win: ${largest_win:.2f}")
            self.largest_loss_label.config(text=f"Largest Loss: ${largest_loss:.2f}")
            
            self.avg_rr_label.config(text=f"Average R:R Ratio: {avg_rr:.2f}")
            self.avg_hold_time_label.config(text=f"Average Hold Time: {str(avg_hold_time).split('.')[0]}")
            
            # Save statistics to database
            self.save_statistics(total_trades, winning_trades, losing_trades, win_rate,
                               profit_factor, avg_win, avg_loss, largest_win, largest_loss, 
                               total_pnl)
            
        except Exception as e:
            logger.error(f"Error calculating statistics: {e}")
            messagebox.showerror("Error", "Failed to calculate statistics.")
        finally:
            db.close()

    def save_statistics(self, total_trades, winning_trades, losing_trades, win_rate,
                       profit_factor, avg_win, avg_loss, largest_win, largest_loss, total_pnl):
        """Save trading statistics to database"""
        db = DatabaseManager()
        try:
            current_date = datetime.now().strftime("%Y-%m-%d")
            db.execute_query('''
                INSERT INTO trading_statistics (
                    date, total_trades, winning_trades, losing_trades, win_rate,
                    profit_factor, average_win, average_loss, largest_win,
                    largest_loss, total_pnl
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (current_date, total_trades, winning_trades, losing_trades, win_rate,
                  profit_factor, avg_win, avg_loss, largest_win, largest_loss, total_pnl))
        except Exception as e:
            logger.error(f"Error saving statistics: {e}")
        finally:
            db.close()

class TradingApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Trading Journal & Portfolio Manager")
        
        # Configure the theme
        style = ttk.Style()
        style.theme_use('clam')
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Create Portfolio Tracker tab
        self.portfolio_tracker = PortfolioTracker(self.notebook)
        self.notebook.add(self.portfolio_tracker, text="Portfolio")
        
        # Create Position Calculator tab
        self.position_calculator = PositionCalculator(self.notebook, 
                                                    portfolio_tracker=self.portfolio_tracker)
        self.notebook.add(self.position_calculator, text="Calculator")
        
        # Create Closed Trades tab
        self.closed_trades = ClosedTradesTab(self.notebook)
        self.notebook.add(self.closed_trades, text="History")
        
        # Create Statistics tab
        self.statistics = StatisticsTab(self.notebook)
        self.notebook.add(self.statistics, text="Statistics")
        
        # Configure menu
        self.setup_menu()
        
        # Bind tab change event
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)

    def setup_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Export Data", command=self.export_all_data)
        file_menu.add_command(label="Import Data", command=self.import_data)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # Settings menu
        settings_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Settings", menu=settings_menu)
        settings_menu.add_command(label="Preferences", command=self.show_preferences)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation", command=self.show_documentation)
        help_menu.add_command(label="About", command=self.show_about)

    def on_tab_change(self, event):
        """Handle tab change events"""
        current_tab = self.notebook.select()
        tab_text = self.notebook.tab(current_tab, "text")
        
        if tab_text == "Portfolio":
            self.portfolio_tracker.refresh()
        elif tab_text == "History":
            self.closed_trades.load_closed_trades()
        elif tab_text == "Statistics":
            self.statistics.calculate_statistics()

    def export_all_data(self):
        """Export all data to a ZIP file"""
        try:
            export_dir = filedialog.askdirectory(title="Select Export Directory")
            if not export_dir:
                return
                
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            zip_filename = f"trading_data_backup_{timestamp}.zip"
            zip_path = Path(export_dir) / zip_filename
            
            db = DatabaseManager()
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                # Export portfolio data
                portfolio_data = db.execute_query("SELECT * FROM portfolio")
                self.export_to_csv(portfolio_data, "portfolio.csv", zipf)
                
                # Export statistics data
                stats_data = db.execute_query("SELECT * FROM trading_statistics")
                self.export_to_csv(stats_data, "statistics.csv", zipf)
                
                # Export journal data
                journal_data = db.execute_query("SELECT * FROM trade_journal")
                self.export_to_csv(journal_data, "journal.csv", zipf)
                
            messagebox.showinfo("Success", f"Data exported successfully to {zip_path}")
        except Exception as e:
            logger.error(f"Error exporting data: {e}")
            messagebox.showerror("Error", "Failed to export data")

    def export_to_csv(self, data, filename, zipf):
        """Helper method to export data to CSV and add to ZIP file"""
        with io.StringIO() as f:
            writer = csv.writer(f)
            writer.writerows(data)
            zipf.writestr(filename, f.getvalue())

    def import_data(self):
        """Import data from backup file"""
        try:
            file_path = filedialog.askopenfilename(
                title="Select Backup File",
                filetypes=[("ZIP files", "*.zip")]
            )
            if not file_path:
                return
                
            if not messagebox.askyesno("Confirm Import", 
                "This will overwrite existing data. Continue?"):
                return
                
            db = DatabaseManager()
            with zipfile.ZipFile(file_path, 'r') as zipf:
                # Import portfolio data
                with zipf.open('portfolio.csv') as f:
                    df = pd.read_csv(f)
                    db.execute_query("DELETE FROM portfolio")
                    for _, row in df.iterrows():
                        db.execute_query("""
                            INSERT INTO portfolio VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                        """, tuple(row))
                
                # Import other data similarly...
                
            messagebox.showinfo("Success", "Data imported successfully")
            self.refresh_all()
        except Exception as e:
            logger.error(f"Error importing data: {e}")
            messagebox.showerror("Error", "Failed to import data")

    def show_preferences(self):
        """Show preferences dialog"""
        preferences_window = tk.Toplevel(self.root)
        preferences_window.title("Preferences")
        preferences_window.geometry("400x300")
        
        # Add preferences options here...
        ttk.Label(preferences_window, 
                 text="Preferences will be available in future updates").pack(pady=20)

    def show_documentation(self):
        """Show documentation"""
        docs_window = tk.Toplevel(self.root)
        docs_window.title("Documentation")
        docs_window.geometry("600x400")
        
        text = tk.Text(docs_window, wrap=tk.WORD, padx=10, pady=10)
        text.pack(fill=tk.BOTH, expand=True)
        
        # Add documentation text
        text.insert(tk.END, """
Trading Journal & Portfolio Manager Documentation

1. Portfolio Tab
   - View and manage open positions
   - Monitor real-time P&L
   - Close positions
   - Add notes to trades

2. Calculator Tab
   - Calculate position sizes
   - Set stop loss and take profit levels
   - View risk/reward metrics
   - Save new trades

3. History Tab
   - View closed trades
   - Export trade history
   - Analyze past performance

4. Statistics Tab
   - View trading performance metrics
   - Track win rate and profit factor
   - Monitor risk management
        """)
        text.config(state=tk.DISABLED)

    def show_about(self):
        """Show about dialog"""
        messagebox.showinfo("About", 
            "Trading Journal & Portfolio Manager\nVersion 1.0\n\n"
            "A comprehensive tool for managing your trading portfolio\n"
            "and tracking trading performance.")

    def refresh_all(self):
        """Refresh all tabs"""
        self.portfolio_tracker.refresh()
        self.closed_trades.load_closed_trades()
        self.statistics.calculate_statistics()

def main():
    root = ThemedTk(theme="arc")  # Use a modern theme
    root.geometry("1200x800")
    app = TradingApp(root)
    root.mainloop()

if __name__ == "__main__":
    main() 
